import socket
import time
from gmssl import sm3, func
from gmssl.sm4 import CryptSM4, SM4_ENCRYPT, SM4_DECRYPT
from hashlib import sha256
import random
MaxBytes=1024*1024
A = 0xFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFC
B = 0x28E9FA9E9D9F5E344D5A9E4BCF6509A7F39789F515AB8F92DDBCBD414D940E93
# 有限域的阶
P = 0xFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF00000000FFFFFFFFFFFFFFFF
G_X = 0x32c4ae2c1f1981195f9904466a39c9948fe30bbff2660be1715a4589334c74c7
G_Y = 0xbc3736a2f4f6779c59bdcee36b692153d0a9877cc62a474002df32e52139f0a0
# 椭圆曲线的阶
N = 0xFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFF7203DF6B21C6052B53BBF40939D54123
G = (G_X, G_Y)#G为基点
#椭圆曲线上的不同点加法运算
def elliptic_add(p,q):
    if p==0 and q==0:return 0
    elif p==0:return q
    elif q==0:return p
    else:
        #保证p[0]<=q[0]
        if p[0]>q[0]:
            temp=p
            p=q
            q=temp
        r=[]
        #当P！=Q时，两点纵坐标相减的值与横坐标相减的值相除就是直线的斜率
        slope=(q[1]-p[1])*number.inverse(q[0]-p[0],P)%P
        r.append((slope**2-p[0]-q[0])%P)
        r.append((slope*(p[0]-r[0])-p[1])%P)
        return (r[0],r[1])
#椭圆曲线上的同一点加法运算（*2运算）
def elliptic_double(p):
    #当P=Q，计算过P(Q)点切线的斜率为椭圆曲线公式两边求导相除：λ = (3*p[0]² + A)/2*p[1]
    r=[]
    slope=(3*(p[0]**2) + A)*number.inverse(2*p[1],P)%P
    r.append((slope**2-2*p[0])%P)
    r.append((slope*(p[0]-r[0])-p[1])%P)
    return (r[0],r[1])
#椭圆曲线上的乘法运算
def elliptic_multiply(s,p):
    n=p
    r=0#无穷远点
    s_bin=bin(s)[2:]#转化为二进制
    s_len=len(s_bin)#二进制长度
    for i in reversed(range(s_len)):#从s_len-1到0逐位计算
        if s_bin[i]=='1':
            r=elliptic_add(r,n)
        n=elliptic_double(n)#n乘2,继续循环
    return r
def shash(s):
    sha=sha256()
    sha.update(s.encode())
    return sha.hexdigest()
    #return sm3.sm3_hash(func.bytes_to_list(bytes(s)))
def KDF(x,klen):
    c=1
    k=""
    for i in range(klen//256):
        k+=shash(x+bin(c)[2:].zfill(32))
        c+=1
    #取剩余部分
    if klen%256!=0:
        k+=shash(x+bin(c)[2:].zfill(32))[:(klen-int(klen//256)*256)//4]
    return bin(int(K,16))[2:].zfill(klen)
def bin_xor(m,t):
    res=""
    for i in range(len(s)):
        if s[i]==t[i]:
            res+='0'
        else:
            res+='1'
    return res
def enc(m,public_key):
    bin_m=bin(m)[2:]#转二进制
    bin_m='0'*(-len(bin_m)%8)+bin_m
    mlen=len(bin_m)
    x,y=public_key#提取公钥
    while(True):
        k=secrets.randbelow(1,N)#生成随机数k
        C1=elliptic_multiply(k,G)#计算C1
        binC1=bin(C1[0])[2:].zfill(256)+bin(C1[1])[2:].zfill(256)
        Cb=elliptic_multiply(k,public_key)#计算Cb
        x_2=bin(Cb[0])[2:].zfill(256)
        y_2=bin(Cb[1])[2:].zfill(256)
        t=KDF(x_2+y_2,mlen)
        if t.cout('0')!=mlen:
            break
        binC2=bin_xor(binm,t)
        C3=shash(x_2+binm+y_2)
        hexC1=hex(int(binC1,2))[2:].zfill(130)
        hexC2=hex(int(binC2,2))[2:].zfill(mlen//4)
        return hexC1+hexC2+C3
              
        
def encrypt(data,public_key):
    data16=str(binascii.b2a_hex(data),'utf8')
    #对信息进行分组
    grouplen=512
    mlist=[]
    i=-1
    for i in range(len(data16)//grouplen):
        addr=i*grouplen
        mlist.append(int(data16[addr:addr+grouplen],16))
    if math.ceil(len(data16)/grouplen)!=len(data16)//grouplrn:
        mlist.append(int(data16[addr+grouplen:],16))
    #对每一组进行加密
    cipher=""
    for m in mlist:
        cipher+=enc(m,public_key)
    return cipher

  
def create_key(data):#生成对称加密密钥，长度16的字符串
    m= hashlib.md5()
    m.update(data.encode("utf-8"))
    n=m.hexdigest()
    return n[0:16]

MaxBytes=1024*1024
host ='127.0.0.1'
port = 11223
client = socket.socket(socket.AF_INET,socket.SOCK_STREAM)
client.settimeout(30)
client.connect((host,port))
public_key=client.recv(MaxBytes).decode()#连接后接收服务器的公钥
while True:
    inputData=input();          #等待输入数据
    if(inputData=="quit"):
        print("退出")
        break
    if(inputData==''):
        print("请输入信息")
        continue

    ###发送数据
    key=create_key(inputData).encode()#生成对称密钥
    iv = b'\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00\x00'
    crypt_sm4 = CryptSM4()
    crypt_sm4.set_key(key, SM4_ENCRYPT)
    encrypt_data = crypt_sm4.crypt_ecb(inputData.encode())  # 对称密钥加密信息
    enc_key = encrypt(key)#对密钥进行加密，利用公钥
    sendBytes = client.send(encrypt_data)#客户端发送数据
    sendBytes2= client.send(enc_key)
    print("客户端发送了："+inputData)
    if sendBytes<=0:
        break;
    recvData = client.recv(MaxBytes)
    if not recvData:
        print('服务器不响应，退出')
        break
    localTime = time.asctime( time.localtime(time.time()))
    print(localTime,'服务器成功接受消息')
    #print(recvData.decode())
client.close()
print("关闭链接")
